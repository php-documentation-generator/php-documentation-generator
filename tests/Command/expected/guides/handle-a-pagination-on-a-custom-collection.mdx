---
slug: handle-a-pagination-on-a-custom-collection
name: Handle a Pagination on a Custom Collection
executable: true
tags: state
---

<div className="sections">
            <div className="section" id="section-1">
            <div className="annotation">
                <a className="anchor" href="#section-1">&#x00a7;</a>
                In case you&#039;re using a custom collection (through a Provider), make sure you return the `Paginator` object to get the full hydra response with `hydra:view` (which contains information about first, last, next and previous page).
The following example shows how to handle it using a custom Provider. You will need to use the Doctrine Paginator and pass it to the API Platform Paginator.
            </div>
            <div className="content">
                ```php
                // src/App/Entity.php
namespace App\Entity;
use ApiPlatform\Metadata\ApiResource;
use ApiPlatform\Metadata\GetCollection;
use App\Repository\BookRepository;
use App\State\BooksListProvider;
use Doctrine\ORM\Mapping as ORM;
/* Use custom Provider on operation to retrieve the custom collection */
#[ApiResource(
    operations: [
        new GetCollection(provider: BooksListProvider::class)
    ]
)]
#[ORM\Entity(repositoryClass: BookRepository::class)]
class Book
{
    #[ORM\Id, ORM\Column, ORM\GeneratedValue]
    public ?int $id = null;
    #[ORM\Column]
    public ?string $title = null;
    #[ORM\Column(name: &#039;is_published&#039;, type: &#039;boolean&#039;)]
    public ?bool $published = null;
}

// src/App/Repository.php
namespace App\Repository;
use App\Entity\Book;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Common\Collections\Criteria;
use Doctrine\ORM\Tools\Pagination\Paginator as DoctrinePaginator;
use Doctrine\Persistence\ManagerRegistry;
class BookRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Book::class);
    }
    public function getPublishedBooks(int $page = 1, int $itemsPerPage = 30): DoctrinePaginator
    {
        /* Retrieve the custom collection and inject it into a Doctrine Paginator object */
        return new DoctrinePaginator(
            $this-&gt;createQueryBuilder(&#039;b&#039;)
                 -&gt;where(&#039;b.published = :isPublished&#039;)
                 -&gt;setParameter(&#039;isPublished&#039;, true)
                 -&gt;addCriteria(
                     Criteria::create()
                         -&gt;setFirstResult(($page - 1) * $itemsPerPage)
                         -&gt;setMaxResults($itemsPerPage)
                 )
        );
    }
}

// src/App/State.php
namespace App\State;
use ApiPlatform\Doctrine\Orm\Paginator;
use ApiPlatform\Metadata\Operation;
use ApiPlatform\State\Pagination\Pagination;
use ApiPlatform\State\ProviderInterface;
use App\Repository\BookRepository;
class BooksListProvider implements ProviderInterface
{
    public function __construct(private readonly BookRepository $bookRepository, private readonly Pagination $pagination)
    {
    }
    public function provide(Operation $operation, array $uriVariables = [], array $context = []): Paginator
    {
        /* Retrieve the pagination parameters from the context thanks to the Pagination object */
        [$page, , $limit] = $this-&gt;pagination-&gt;getPagination($operation, $context);
        /* Decorates the Doctrine Paginator object to the API Platform Paginator one */
        return new Paginator($this-&gt;bookRepository-&gt;getPublishedBooks($page, $limit));
    }
}

// src/App/Playground.php
namespace App\Playground;
use Symfony\Component\HttpFoundation\Request;
function request(): Request
{
    return Request::create(&#039;/books.jsonld&#039;, &#039;GET&#039;);
}

// src/DoctrineMigrations.php
namespace DoctrineMigrations;
use Doctrine\DBAL\Schema\Schema;
use Doctrine\Migrations\AbstractMigration;
final class Migration extends AbstractMigration
{
    public function up(Schema $schema): void
    {
        $this-&gt;addSql(&#039;CREATE TABLE book (id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, title VARCHAR(255) NOT NULL, is_published SMALLINT NOT NULL)&#039;);
    }
}

// src/App/Fixtures.php
namespace App\Fixtures;
use App\Entity\Book;
use Doctrine\Bundle\FixturesBundle\Fixture;
use Doctrine\Persistence\ObjectManager;
use Zenstruck\Foundry\AnonymousFactory;
use function Zenstruck\Foundry\faker;
final class BookFixtures extends Fixture
{
    public function load(ObjectManager $manager): void
    {
        /* Create books published or not */
        $factory = AnonymousFactory::new(Book::class);
        $factory-&gt;many(5)-&gt;create(static function (int $i): array {
            return [
                &#039;title&#039; =&gt; faker()-&gt;title(),
                &#039;published&#039; =&gt; false,
            ];
        });
        $factory-&gt;many(35)-&gt;create(static function (int $i): array {
            return [
                &#039;title&#039; =&gt; faker()-&gt;title(),
                &#039;published&#039; =&gt; true,
            ];
        });
    }
}

// src/App/Tests.php
namespace App\Tests;
use ApiPlatform\Symfony\Bundle\Test\ApiTestCase;
use App\Entity\Book;
use PhpDocumentGenerator\Playground\TestGuideTrait;
final class BookTest extends ApiTestCase
{
    use TestGuideTrait;
    public function testTheCustomCollectionIsPaginated(): void
    {
        $response = static::createClient()-&gt;request(&#039;GET&#039;, &#039;/books.jsonld&#039;);
        $this-&gt;assertResponseIsSuccessful();
        $this-&gt;assertMatchesResourceCollectionJsonSchema(Book::class, &#039;_api_/books{._format}_get_collection&#039;, &#039;jsonld&#039;);
        $this-&gt;assertNotSame(0, $response-&gt;toArray(false)[&#039;hydra:totalItems&#039;], &#039;The collection is empty.&#039;);
        $this-&gt;assertJsonContains([
            &#039;hydra:totalItems&#039; =&gt; 35,
            &#039;hydra:view&#039; =&gt; [
                &#039;@id&#039; =&gt; &#039;/books.jsonld?page=1&#039;,
                &#039;@type&#039; =&gt; &#039;hydra:PartialCollectionView&#039;,
                &#039;hydra:first&#039; =&gt; &#039;/books.jsonld?page=1&#039;,
                &#039;hydra:last&#039; =&gt; &#039;/books.jsonld?page=2&#039;,
                &#039;hydra:next&#039; =&gt; &#039;/books.jsonld?page=2&#039;,
            ],
        ]);
    }
}


                ```
            </div>
        </div>
    </div>
